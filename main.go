package main

import (
    "fmt"
    "math"
)

// Перемножение цепочки матриц

func matrixMultiply(A, B [][]int) [][]int {
    if len(A[0]) != len(B) {
        panic("Матрицы несовместны!")
    }
    C := make([][]int, len(A))
    for i := range C {
        C[i] = make([]int, len(B[0]))
    }
    count := 0
    for i := 0; i < len(A); i++ {
        for j := 0; j < len(B[0]); j++ {
            C[i][j] = 0
            for k := 0; k < len(A[0]); k++ {
                C[i][j] += A[i][k] * B[k][j]
                count++
            }
        }
    }
    fmt.Println("Кол-во скалярных умножений:", count)
    return C
}

func printOrder(s [][]int, i, j int) {
    if i == j {
        fmt.Printf("A%d", i)
    } else {
        fmt.Print("(")
        printOrder(s, i, s[i][j])
        printOrder(s, s[i][j]+1, j)
        fmt.Print(")")
    }
}

func main() {
    p := []int{10, 100, 5, 50, 150}
    n := len(p) - 1

	// инициализация матриц m и s
    m := make([][]int, n)
    s := make([][]int, n)
    for i := range m {
        m[i] = make([]int, n)
        s[i] = make([]int, n)
        for a := range m[i] {
            m[i][a] = 0
            s[i][a] = 0
        }
    }

    // итерационный алгоритм
    for l := 1; l < n; l++ {
        for i := 0; i < n - l; i++ {
            j := i + l
            m[i][j] = math.MaxInt32
            for k := i; k < j; k++ {
                q := m[i][k] + m[k+1][j] + p[i]*p[k+1]*p[j+1]
                if q < m[i][j] {
                    m[i][j] = q
                    s[i][j] = k
                }
            }
        }
    }

    fmt.Println(m[0][n-1])
    printOrder(s, 0, n-1)
}

/* TODO:

Лабораторная работа №3. Методы динамического программирования.
Задание.
С помощью методов динамического программирования реализовать
алгоритм решения зада в соответствии с вариантом. Предусмотреть ввод
начальных условий и вывод решения.
Варианты:
1 Задача о разрезании стержня;
2 Перемножение цепочки матриц;
3 Наидлиннейшая общая последовательность;
Результаты лабораторной работы оформить в виде отчета с результатами
работы программы.
Формулировка задач и их аналитическое решение представлены в книге
Т.Кормен, Ч.Лейзерсон, Р.Ривест, К.Штайн - Алгоритмы. Построение и
анализ.
в главе 15
Задача 1 - 15.1
Задача 2 - 15.2
Задача 3 - 15.3
*/